{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HTTPX-CACHE Quickstart httpx-cache is a simple utility for caching (sync/async) responses from httpx. It provides a custom transport that can be used with any httpx Client. import httpx import httpx_cache transport = httpx_cache . CacheControlTransport () with httpx . Client ( transport = transport ) as client : response = client . get ( \"https://httpbin.org/get\" ) Read the User Guide for a complete walk-through. Installation Install with pip: $ pip install httpx-cache Requires Python 3.6+ and HTTPX 0.21+.","title":"Introduction"},{"location":"#httpx-cache","text":"","title":"HTTPX-CACHE"},{"location":"#quickstart","text":"httpx-cache is a simple utility for caching (sync/async) responses from httpx. It provides a custom transport that can be used with any httpx Client. import httpx import httpx_cache transport = httpx_cache . CacheControlTransport () with httpx . Client ( transport = transport ) as client : response = client . get ( \"https://httpbin.org/get\" ) Read the User Guide for a complete walk-through.","title":"Quickstart"},{"location":"#installation","text":"Install with pip: $ pip install httpx-cache Requires Python 3.6+ and HTTPX 0.21+.","title":"Installation"},{"location":"api/","text":"API documentation Cache class httpx_cache. DictCache ( * , data=NOTHING , serializer=NOTHING ) close ( self ) Close cache. delete ( self , request ) get ( self , request ) lock set ( self , * , request , response , content=None ) class httpx_cache. AsyncDictCache ( * , data=NOTHING , serializer=NOTHING ) aclose ( self ) Close cache. adelete ( self , request ) aget ( self , request ) aset ( self , * , request , response , content=None ) lock class httpx_cache. FileCache ( * , serializer=NOTHING , cache_dir=NOTHING ) close ( self ) Close cache. delete ( self , request ) get ( self , request ) lock A reader/writer lock. This lock allows for simultaneous readers to exist but only one writer to exist for use-cases where it is useful to have such types of locks. Currently a reader can not escalate its read lock to a write lock and a writer can not acquire a read lock while it is waiting on the write lock. In the future these restrictions may be relaxed. This can be eventually removed if http://bugs.python.org/issue8800 ever gets accepted into the python standard threading library... set ( self , * , request , response , content=None ) class httpx_cache. AsyncFileCache ( * , serializer=NOTHING , cache_dir=NOTHING ) aclose ( self ) Close cache. adelete ( self , request ) aget ( self , request ) aset ( self , * , request , response , content=None ) lock !!! Note FileCache only supports MsgPackSerializer and BytesSerializer Serializer class httpx_cache. NullSerializer ( ) deserialize ( self , data ) Do Nothing. dumps ( self , * , response , content=None ) loads ( self , * , data , request=None ) serialize ( self , data ) Do Nothing. class httpx_cache. StringSerializer ( ) deserialize ( self , data ) dumps ( self , * , response , content=None ) Dumps amd httpx Response and serialize it to be stored in cache. The content is provided separatly because in most cases, the response contains a stream that completly read before caching. When used with an httpx.BaseTransport the content is generally provided via a callback, when the user as completly read the stream (we wrapp the response stream so that a callback is called when the stream is fully loaded). Usage: >>> # simplest usage. >>> resp = httpx.Response(200, ...) >>> data = Serializer().dumps(response=resp, content=resp.read()) Args: response: httpx.Response content: optional content in bytes of the httpx.Response Returns: dumped and serialized response. loads ( self , * , data , request=None ) Deserialize and loads an httpx.Response from serialized data. Data will first be deserialized before creating a new httpx.Response object. The bytes content will be wrapped in an httpx.ByteStream. Args: data: dumped data to load Returns: httpx.Response serialize ( self , data ) class httpx_cache. BytesSerializer ( ) deserialize ( self , data ) dumps ( self , * , response , content=None ) Dumps amd httpx Response and serialize it to be stored in cache. The content is provided separatly because in most cases, the response contains a stream that completly read before caching. When used with an httpx.BaseTransport the content is generally provided via a callback, when the user as completly read the stream (we wrapp the response stream so that a callback is called when the stream is fully loaded). Usage: >>> # simplest usage. >>> resp = httpx.Response(200, ...) >>> data = Serializer().dumps(response=resp, content=resp.read()) Args: response: httpx.Response content: optional content in bytes of the httpx.Response Returns: dumped and serialized response. loads ( self , * , data , request=None ) Deserialize and loads an httpx.Response from serialized data. Data will first be deserialized before creating a new httpx.Response object. The bytes content will be wrapped in an httpx.ByteStream. Args: data: dumped data to load Returns: httpx.Response serialize ( self , data ) class httpx_cache. DictSerializer ( ) deserialize ( self , data ) dumps ( self , * , response , content=None ) Dumps amd httpx Response and serialize it to be stored in cache. The content is provided separatly because in most cases, the response contains a stream that completly read before caching. When used with an httpx.BaseTransport the content is generally provided via a callback, when the user as completly read the stream (we wrapp the response stream so that a callback is called when the stream is fully loaded). Usage: >>> # simplest usage. >>> resp = httpx.Response(200, ...) >>> data = Serializer().dumps(response=resp, content=resp.read()) Args: response: httpx.Response content: optional content in bytes of the httpx.Response Returns: dumped and serialized response. loads ( self , * , data , request=None ) Deserialize and loads an httpx.Response from serialized data. Data will first be deserialized before creating a new httpx.Response object. The bytes content will be wrapped in an httpx.ByteStream. Args: data: dumped data to load Returns: httpx.Response serialize ( self , data ) class httpx_cache. MsgPackSerializer ( ) Simple serializer to bytes using msgpack. deserialize ( self , data ) dumps ( self , * , response , content=None ) Dumps amd httpx Response and serialize it to be stored in cache. The content is provided separatly because in most cases, the response contains a stream that completly read before caching. When used with an httpx.BaseTransport the content is generally provided via a callback, when the user as completly read the stream (we wrapp the response stream so that a callback is called when the stream is fully loaded). Usage: >>> # simplest usage. >>> resp = httpx.Response(200, ...) >>> data = Serializer().dumps(response=resp, content=resp.read()) Args: response: httpx.Response content: optional content in bytes of the httpx.Response Returns: dumped and serialized response. loads ( self , * , data , request=None ) Deserialize and loads an httpx.Response from serialized data. Data will first be deserialized before creating a new httpx.Response object. The bytes content will be wrapped in an httpx.ByteStream. Args: data: dumped data to load Returns: httpx.Response serialize ( self , data ) Transports class httpx_cache. CacheControlTransport ( * , cacheable_methods=('GET',) , cacheable_status_codes=(200, 203, 300, 301, 308) , transport=NOTHING , cache=NOTHING ) close ( self ) handle_request ( self , request ) is_request_cacheable ( self , request ) is_response_cacheable ( self , response ) class httpx_cache. AsyncCacheControlTransport ( * , cacheable_methods=('GET',) , cacheable_status_codes=(200, 203, 300, 301, 308) , transport=NOTHING , cache=NOTHING ) aclose ( self ) handle_async_request ( self , request ) is_request_cacheable ( self , request ) is_response_cacheable ( self , response )","title":"Developper Interface"},{"location":"api/#api-documentation","text":"","title":"API documentation"},{"location":"api/#cache","text":"class httpx_cache. DictCache ( * , data=NOTHING , serializer=NOTHING ) close ( self ) Close cache. delete ( self , request ) get ( self , request ) lock set ( self , * , request , response , content=None ) class httpx_cache. AsyncDictCache ( * , data=NOTHING , serializer=NOTHING ) aclose ( self ) Close cache. adelete ( self , request ) aget ( self , request ) aset ( self , * , request , response , content=None ) lock class httpx_cache. FileCache ( * , serializer=NOTHING , cache_dir=NOTHING ) close ( self ) Close cache. delete ( self , request ) get ( self , request ) lock A reader/writer lock. This lock allows for simultaneous readers to exist but only one writer to exist for use-cases where it is useful to have such types of locks. Currently a reader can not escalate its read lock to a write lock and a writer can not acquire a read lock while it is waiting on the write lock. In the future these restrictions may be relaxed. This can be eventually removed if http://bugs.python.org/issue8800 ever gets accepted into the python standard threading library... set ( self , * , request , response , content=None ) class httpx_cache. AsyncFileCache ( * , serializer=NOTHING , cache_dir=NOTHING ) aclose ( self ) Close cache. adelete ( self , request ) aget ( self , request ) aset ( self , * , request , response , content=None ) lock !!! Note FileCache only supports MsgPackSerializer and BytesSerializer","title":"Cache"},{"location":"api/#serializer","text":"class httpx_cache. NullSerializer ( ) deserialize ( self , data ) Do Nothing. dumps ( self , * , response , content=None ) loads ( self , * , data , request=None ) serialize ( self , data ) Do Nothing. class httpx_cache. StringSerializer ( ) deserialize ( self , data ) dumps ( self , * , response , content=None ) Dumps amd httpx Response and serialize it to be stored in cache. The content is provided separatly because in most cases, the response contains a stream that completly read before caching. When used with an httpx.BaseTransport the content is generally provided via a callback, when the user as completly read the stream (we wrapp the response stream so that a callback is called when the stream is fully loaded). Usage: >>> # simplest usage. >>> resp = httpx.Response(200, ...) >>> data = Serializer().dumps(response=resp, content=resp.read()) Args: response: httpx.Response content: optional content in bytes of the httpx.Response Returns: dumped and serialized response. loads ( self , * , data , request=None ) Deserialize and loads an httpx.Response from serialized data. Data will first be deserialized before creating a new httpx.Response object. The bytes content will be wrapped in an httpx.ByteStream. Args: data: dumped data to load Returns: httpx.Response serialize ( self , data ) class httpx_cache. BytesSerializer ( ) deserialize ( self , data ) dumps ( self , * , response , content=None ) Dumps amd httpx Response and serialize it to be stored in cache. The content is provided separatly because in most cases, the response contains a stream that completly read before caching. When used with an httpx.BaseTransport the content is generally provided via a callback, when the user as completly read the stream (we wrapp the response stream so that a callback is called when the stream is fully loaded). Usage: >>> # simplest usage. >>> resp = httpx.Response(200, ...) >>> data = Serializer().dumps(response=resp, content=resp.read()) Args: response: httpx.Response content: optional content in bytes of the httpx.Response Returns: dumped and serialized response. loads ( self , * , data , request=None ) Deserialize and loads an httpx.Response from serialized data. Data will first be deserialized before creating a new httpx.Response object. The bytes content will be wrapped in an httpx.ByteStream. Args: data: dumped data to load Returns: httpx.Response serialize ( self , data ) class httpx_cache. DictSerializer ( ) deserialize ( self , data ) dumps ( self , * , response , content=None ) Dumps amd httpx Response and serialize it to be stored in cache. The content is provided separatly because in most cases, the response contains a stream that completly read before caching. When used with an httpx.BaseTransport the content is generally provided via a callback, when the user as completly read the stream (we wrapp the response stream so that a callback is called when the stream is fully loaded). Usage: >>> # simplest usage. >>> resp = httpx.Response(200, ...) >>> data = Serializer().dumps(response=resp, content=resp.read()) Args: response: httpx.Response content: optional content in bytes of the httpx.Response Returns: dumped and serialized response. loads ( self , * , data , request=None ) Deserialize and loads an httpx.Response from serialized data. Data will first be deserialized before creating a new httpx.Response object. The bytes content will be wrapped in an httpx.ByteStream. Args: data: dumped data to load Returns: httpx.Response serialize ( self , data ) class httpx_cache. MsgPackSerializer ( ) Simple serializer to bytes using msgpack. deserialize ( self , data ) dumps ( self , * , response , content=None ) Dumps amd httpx Response and serialize it to be stored in cache. The content is provided separatly because in most cases, the response contains a stream that completly read before caching. When used with an httpx.BaseTransport the content is generally provided via a callback, when the user as completly read the stream (we wrapp the response stream so that a callback is called when the stream is fully loaded). Usage: >>> # simplest usage. >>> resp = httpx.Response(200, ...) >>> data = Serializer().dumps(response=resp, content=resp.read()) Args: response: httpx.Response content: optional content in bytes of the httpx.Response Returns: dumped and serialized response. loads ( self , * , data , request=None ) Deserialize and loads an httpx.Response from serialized data. Data will first be deserialized before creating a new httpx.Response object. The bytes content will be wrapped in an httpx.ByteStream. Args: data: dumped data to load Returns: httpx.Response serialize ( self , data )","title":"Serializer"},{"location":"api/#transports","text":"class httpx_cache. CacheControlTransport ( * , cacheable_methods=('GET',) , cacheable_status_codes=(200, 203, 300, 301, 308) , transport=NOTHING , cache=NOTHING ) close ( self ) handle_request ( self , request ) is_request_cacheable ( self , request ) is_response_cacheable ( self , response ) class httpx_cache. AsyncCacheControlTransport ( * , cacheable_methods=('GET',) , cacheable_status_codes=(200, 203, 300, 301, 308) , transport=NOTHING , cache=NOTHING ) aclose ( self ) handle_async_request ( self , request ) is_request_cacheable ( self , request ) is_response_cacheable ( self , response )","title":"Transports"},{"location":"guide/","text":"User Guide httpx-cache provides a sync/async cache transport that can be configured to use multiple cache types and serializers Usage with httpx.Client import httpx import httpx_cache transport = httpx_cache . CacheControlTransport () with httpx . Client ( transport = transport ) as client : response = client . get ( \"https://httpbin.org/get\" ) The created transport behaves the same way as the default httpx.HTTPTransport with defauls args and kwargs. By default the cache is stored in memory in a python dict and serialzed using MsgPack . Usage with httpx.AsyncClient import httpx import httpx_cache transport = httpx_cache . AsyncCacheControlTransport () with httpx . AsyncClient ( transport = transport ) as client : response = await client . get ( \"https://httpbin.org/get\" ) The created transport behaves the same way as the default httpx.AsyncHTTPTransport with defauls args and kwargs. By default the cache is stored in memory in a python dict and serialzed using MsgPack . Cache 2 types of caches are supported for the time being: Dictcache/AsyncDictCache import httpx_cache transport = httpx_cache . CacheControlTransport ( cache = httpx_cache . DictCache ()) async_transport = httpx_cache . AsyncCacheControlTransport ( cache = httpx_cache . AsyncDictCache ()) a DictCache can also take a dict with initial data as input but it's not recommended. FileCache/AsyncFileCache import httpx_cache transport = httpx_cache . CacheControlTransport ( cache = httpx_cache . FileCache ()) async_transport = httpx_cache . AsyncCacheControlTransport ( cache = httpx_cache . AsyncFileCache ()) By default the cached files will be saved in $HOME/.cache/httpx-cache folder. It can be customized using the argument: cache_dir","title":"User Guide"},{"location":"guide/#user-guide","text":"httpx-cache provides a sync/async cache transport that can be configured to use multiple cache types and serializers","title":"User Guide"},{"location":"guide/#usage-with-httpxclient","text":"import httpx import httpx_cache transport = httpx_cache . CacheControlTransport () with httpx . Client ( transport = transport ) as client : response = client . get ( \"https://httpbin.org/get\" ) The created transport behaves the same way as the default httpx.HTTPTransport with defauls args and kwargs. By default the cache is stored in memory in a python dict and serialzed using MsgPack .","title":"Usage with httpx.Client"},{"location":"guide/#usage-with-httpxasyncclient","text":"import httpx import httpx_cache transport = httpx_cache . AsyncCacheControlTransport () with httpx . AsyncClient ( transport = transport ) as client : response = await client . get ( \"https://httpbin.org/get\" ) The created transport behaves the same way as the default httpx.AsyncHTTPTransport with defauls args and kwargs. By default the cache is stored in memory in a python dict and serialzed using MsgPack .","title":"Usage with httpx.AsyncClient"},{"location":"guide/#cache","text":"2 types of caches are supported for the time being:","title":"Cache"},{"location":"guide/#dictcacheasyncdictcache","text":"import httpx_cache transport = httpx_cache . CacheControlTransport ( cache = httpx_cache . DictCache ()) async_transport = httpx_cache . AsyncCacheControlTransport ( cache = httpx_cache . AsyncDictCache ()) a DictCache can also take a dict with initial data as input but it's not recommended.","title":"Dictcache/AsyncDictCache"},{"location":"guide/#filecacheasyncfilecache","text":"import httpx_cache transport = httpx_cache . CacheControlTransport ( cache = httpx_cache . FileCache ()) async_transport = httpx_cache . AsyncCacheControlTransport ( cache = httpx_cache . AsyncFileCache ()) By default the cached files will be saved in $HOME/.cache/httpx-cache folder. It can be customized using the argument: cache_dir","title":"FileCache/AsyncFileCache"}]}